/*
 * @description - Synesthesia Symphony
 * @copyright - 2014 Shipping Soon
 * @source - https://github.com/shippingsoon/Synesthesia-Symphony/
 * @website - https://www.shippingsoon.com/synesthesia-symphony/
 * @version - v0.06
 * @license - GPLv3
 */

'use strict';

//Load 3rd party modules.
var crypto = require('crypto');

//Load 1st party modules.
var config = require('server_settings');
var server_utils = require('server_utils');


/*
 * Logs error messages to stderr.
 * @return {Undefined}
 */
exports.errorHandler = function() {
	if (config.server.debug)
		console.error.apply(console, arguments);
};


/*
 * Encryption
 * @param {String} options.plain_text - Plain text to be encrpted
 * @param {String} options.paraphrase - The paraphrase.
 * @param {String} options.iv - The randomly generated initiation vector.
 * @param {String} options.hmac_key - The hmac key.
 * @param {String} options.hmac_algorithm - The hmac algorithm.
 * @param {String} options.algorithm - The encrption algorithm.
 * @return {Object}
 */
exports.encrypt = function(options) {
	var algorithm = options.algorithm || 'AES-256-CBC';
	var hmac_algorithm = options.hmac_algorithm || 'SHA256';
	var iv = new Buffer(options.iv || crypto.randomBytes(16), 'hex');
	var paraphrase = options.paraphrase || crypto.randomBytes(32).toString('hex');
	var key = new Buffer(crypto.createHash('SHA256').update(paraphrase).digest('hex'), 'hex');
	var hmac_key = new Buffer(options.hmac_key || crypto.randomBytes(32), 'hex');
	var encryptor = crypto.createCipheriv(algorithm, key, iv);
	var plain_text = options.plain_text;
	
	if (plain_text === undefined || plain_text === null) {
		exports.errorHandler('Plaintext cannot be empty');
		return null;
	}
	encryptor.setEncoding('hex');
	encryptor.write(plain_text);
	encryptor.end();
	var cipher_text = encryptor.read();
	var hmac = crypto.createHmac(hmac_algorithm, hmac_key);
	
	hmac.update(cipher_text);
	hmac.update(iv.toString('hex'));

	return {
		cipher_text: cipher_text,
		paraphrase: paraphrase,
		iv: iv.toString('hex'),
		hmac_key: hmac_key.toString('hex'),
		hmac_algorithm: hmac_algorithm,
		algorithm: algorithm
	};
};

/*
 * Decryption
 * @param {String} options.cipher_text - Cipher text.
 * @param {String} options.paraphrase - The paraphrase.
 * @param {String} options.iv - The initiation vector.
 * @param {String} options.hmac_key - The hmac key.
 * @param {String} options.hmac_algorithm - The hmac algorithm.
 * @param {String} options.algorithm - The encrption algorithm.
 * @return {Object}
 */
exports.decrypt = function(options) {
	var algorithm = options.algorithm || 'AES-256-CBC';
	var hmac_algorithm = options.hmac_algorithm || 'SHA256';
	var iv = new Buffer(options.iv, 'hex');
	var key = new Buffer(crypto.createHash('SHA256').update(options.paraphrase).digest('hex'), 'hex');
	var hmac_key = new Buffer(options.hmac_key, 'hex');
	var decryptor = crypto.createDecipheriv(algorithm, key, iv);
	decryptor.update(options.cipher_text, 'hex', 'utf8');
	
	try {
		var plain_text = decryptor.final('utf8');
	}
	catch (e) {
		exports.errorHandler("createDecipheriv() error: %s", e);
		return null;
	}

	return {
		plain_text: plain_text,
		iv: iv.toString('hex'),
		paraphrase: options.paraphrase,
		hmac_key: hmac_key.toString('hex'),
		hmac_algorithm: hmac_algorithm,
		algorithm: algorithm
	};
};

/*
 * Requires a valid session.
 * @param {Object} req - Server request.
 * @param {Object} res - Server response.
 * @param {Function} next - Invokes next callback.
 * @return {Undefined}
 */
exports.requireLogin = function(req, res, next) {
	if (!req.user) {
		res.redirect('/login');
	}
	else
		next();
};

/*
 * Checks to see if a user exists. Deletes the session if the user is not found.
 * @param {Object} req - Server request.
 * @param {Object} res - Server response.
 * @param {Function} next - Invokes next callback.
 * @return {Undefined}
 */
exports.loadSession = function(req, res, next) {
	if (req.session && req.session.user) {
		//Load the users model.
		var Users = req.app.get('models').users;

		Users
			.findOne({where: {email_address: req.session.user.email_address}})
			.then(function(user){
				//User was found refresh the session.
				if (user) {
					//Store the session.
					req.session.user = req.user = res.locals.user = {
						user_id: user.user_id,
						user_group_id: user.user_group_id,
						user_name: user.user_name,
						email_address: user.email_address,
					};
				}
				//Clear the user's session.
				else {
					req.session.reset();
				}

				next();
			})
			.catch(server_utils.errorHandler);
	}
	else 
		next();
};

/*
 * Returns the base URL
 * @param {Object} req - Server request.
 * @param {String} path - The URI.
 * @return {String}
 */
exports.baseUrl = function(req, path) {
	var base_url = req.protocol + '://' + req.hostname + ':' + req.app.server.address().port + '/';
	return base_url + (path || '');
};

/*
 * Registers a new user.
 * @param {Object} Users - Sequelize users model.
 * @param {Number} user.user_group_id - User group ID.
 * @param {String} user.user_name - User's name.
 * @param {String} user.email_address - User's email address.
 * @param {String} user.password - User's password.
 * @return {Undefined}.
 */
exports.registerUser = function(Users, user) {
	crypto.randomBytes(64, function(err, buffer) {
		if (err) {
			server_utils.errorHandler("randomBytes() error: %s", err);
			return false;
		}
		else {
			var salt = buffer.toString('base64');

			crypto.pbkdf2(user.password, salt, 4096, 64, 'sha256', function(err, key) {
				if (err) {
					server_utils.errorHandler("registerUser() error: %s", err);
					return false;
				}
				else {
					//Store the user's encrypted password and salt.
					user.password = key.toString('base64');
					user.salt = salt;
					
					//Insert the user.
					Users
						.create(user)
						.then(function(user){
							return (user) ? true : false;
						})
						.catch(server_utils.errorHandler);
				}
			});
		}
	});

	return false;
};

/*
 * Verifies a user's password.
 * @param {String} user.salt - User's salt.
 * @param {String} user.password - User's password.
 * @param {Function} callback - Callback.
 * @return {Boolean}.
 */
/*
exports.verifyUserPassword = function(user, callback) {
	crypto.pbkdf2(user.password, user.salt, 4096, 64, 'sha256', function(err, key) {
		var is_valid_password = false;
		
		if (err) {
			server_utils.errorHandler("verifyUserPassword() error: %s", err);
		}
		else {
			is_valid_password = (user.password === key.toString('base64'));
		}

		callback(is_valid_password);
	});
};
*/
